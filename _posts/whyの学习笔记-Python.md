---
title: whyの学习笔记:Python
date: 2018-04-10 10:38:51
tags:
- 编程
- python
categories: python
thumbnail: "why的python学习记录！/python.jpg"
---

<h1>why的Python学习记录!</h1>

<h4>大家一起愉快地写代码叭!</h4>

***
![](https://raw.githubusercontent.com/creeper121386/blog-file/master/timg.jpeg)

<!-- more -->

<h2>目录</h2>

* [linux下的Python配置](#t2)
* [python运算符](#t3)
* [控制流与API](#t4)
* [数据类型](#t5)
* [自定义函数](#t6)
* [高级操作](#t7)
* [文件I/O](#t8)
* [面向对象(OOP)](#t9)
* [多进程&多线程](#t10)

***

<h2 id="t2">Linux下的Python配置</h2>

atom安装Python插件，或者使用IDE (spyder,pycharm)。程序运行的两种模式：命令行模式（直接运行）与Python交互模式（逐句执行）。

***
<h2 id="t3">Python运算符</h2>

>+,-,* ,/,//（取商的整数部分）,x**y （表示x^y ）,>>,<<,&,|,^,~,>,<,>=,<=,==,!=,not,and,or

<h2 id="t4">控制流与API</h2>

<h3>需要注意的事情：</h3>

句末不加分号（当然如果你想加的话也可以23333），函数块用缩进表示，字符串可以用单引号引用。

**标准输入输出函数：** `print(),input()`。Print末尾自动换行，可以通过在末尾添加逗号来取消末尾的换行符。print语句可以像c语言一样使用转换说明来打印变量。如
```python
print(“hello %s”%(“world!”))。
```

**打印彩色&粗体&高亮字体：**
```python
print("this is a \033[显示方式;字体颜色;背景颜色m text \033[0m  other text")
```

相关参数如下：

字体色|背景色|颜色描述
:-:|:--:|:--:|
30 |40|黑色  |
31 |41|红色  |
32 |42|绿色  |
33 |43|黃色  |
34 |44|蓝色  |
35 |45|紫红色|
36 |46|青蓝色|
37 |47|白色  |

显示方式     |      效果
:---------:|:--------:
0           |     终端默认设置
1           |     高亮显示
4           |     使用下划线
5           |     闪烁
7           |     反白显示
8           |     不可见

特别地，`%s`除了表示字符串以外，也可以表示`list`。`a=input(“xxxxxxx”)`表示把输入的数据赋值给a，并在输入前显示一行提示语句。在`python3`中`input`函数默认将键盘输入作为`str`看待，若想接受int类型，应当使用`int(input())`.
返回字符串长度/列表元素个数：`len()`

**条件函数if：**
```python
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
<执行4>
```

**循环语句：** `for x in…`循环：把…(一个数组)的每一个元素赋值给x（即x的值在循环体中表示的是数组的相应元素）执行循环体。

**range(101)：** 生成一个元素为整数0-100的序列（数组）。Range(m,n)生成从m到n前一个数字的数组。`Range(1,5,2)`中2表示步长（缺省为1）生成list[1,3]

**while循环：** `while x`，同c语言。可使用break退出循环，或用continue结束本轮，执行下次循环。
注：在while或for语句块后可以跟随else。若在循环体中使用break语句，else部分也会被跳过。

**尾递归：** 函数的最后一步只调用函数本身，且返回语句不含表达式的递归。如：
```python
def tailrecsum(x, running_total=0):
if x == 0:
return running_total
else:
return tailrecsum(x - 1, running_total + x)
```

是尾递归，而：

```python
def recsum(x):
  if x == 1:
    return x
  else:
return x + recsum(x - 1)
```

不是尾递归。因为函数的最后一步return语句中有表达式。使用尾递归，使得循环时内层函数不必使用外层函数中的值，无需储存上一层函数中的数据，只占用一个栈帧，可以避免栈溢出风险。

**暂停1s输出：** time.sleep(1)

***

<h2 id="t5">数据类型</h2>

**整形数据（int），浮点（float），字符串（str），布尔值（bool），none：** 同c语言

**复数（complex）：** a+bi表示为`complex(a,b)`或`a+bj`，其中a和b是浮点型。

#### **列表（list）：**
是可变的数据类型。定义：`A=[a,b,c]`，列表的内容可以是不同的类，甚至可以是list，若这么做，相当于二维数组。
列表通过下标访问。`A[-n]`表示倒数第n个元素。

*  `A.append(‘xxxxx’)`表示向列表末尾加入元素
*  `A.insert(n,’xxxxx’)`表示向A[n]处插入新元素。
*  删除list的元素:使用`A.pop()`删除末尾元素，`A.pop(i)`删除指定位置的元素（也可使用`del(A[i])`来删除指定位置的元素）。
*  对list的元素进行排序：使用`A.sort()`语句。使用该语句后，List本身的内容会被改变。

#### **元组（tuple,const）：**
是不可变的数据类型。一旦初始化就不能修改。其内容也可以是不同的类，包括list。成员中有list时，**list中的元素可变**，但不能对list整体修改。元组中的元素通过下标访问。定义：`A=(a,b,c)`。元素只有一个时，应定义为`A=(a,)`来消歧义。

#### **字典（dict）：**
是可变的数据类型。查找速度快，但内存浪费多（空间换取时间）。声明语句如

```python
d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
```

每个元素的名称（**key**）和值一一对应，key不能重复，且必须为不可变对象。字典中的某个key代表的元素表示为：`d['Jack']`，对应值为88。

*  通过`’x’ in d`语句判断该元素是否存在（是否被定义）。存在则该语句的值为真，反之为假。
*  也可以使用`d.get(‘Michael’)`表达式判断，若该键没有对应的值则返回none。该表达式可指定不存在时的返回值：`d.get(‘Michael’，-1)`
*  使用`d.keys()`单独提取dict中的key为一个数组；
*  使用`d.values()`单独提取值为一个数组；
*  使用`d.items()`将key和对应的值同时提取为数组，数组的每个元素是一个tuple。

**注意：** 此处的“数组”是不严谨说法，其实他们的数据类型既不是list也不是tuple。

#### **Set：**
一组key的集合，但不存储值。声明：`s = set([1, 2, 3])`。
Key不可变，且不能重复，因此set的元素都是不可变对象，并且没有相同元素。Add(key)可以加入新元素，
*  `remove(key)`可以删除元素。
*  两个set可以进行数学上集合的交并操作，使用`&`和`|`。

#### **字符串(str,const)：**
大致同c，不可变的类型。若`a=’abc’`
*  想要改变a的值，可以使用`a=a.replace(‘a’,’A’)`。也只有字符串类型可以使用replace函数。Replace函数的返回值是改变后的串内容，但a本身并没有改变。要想改变，需要进行赋值操作，即`a=a.replace(‘a’,’A’)`。
*  将字符串内容两边加上空格：`s.center()`。
*  将字符串s中的所有大写字母变成小写，使用`s.lower()`方法。
*  变成大写：`s.upper()`。

字符串中可以用转义字符`\’`表示单引号，`\\`表示反斜线，在行末使用`\`可以在下一行续写字符串。

**可迭代对象：** 包括集合数据类型，如list、tuple、dict、set、str等；
以及generator，包括生成器和带yield的generator function。可以使用函数`isinstance()`来判断一个对象是否是可迭代对象。可以被`next()`函数不断返回下一个值的对象称为迭代器（iterator）。For循环本质就是不断调用next函数来实现的。

***

<h2 id="t6">自定义函数</h2>

函数定义语句：

```python
def 函数名(参数):
	函数体
```
Python中的自定义函数使用`return`语句返回值。可以返回多个值，如`return 0,1`。返回多个值的本质是返回了一个tuple。若不写返回语句，则返回值为none。
与含有函数定义的py文件的同级目录下的文件可以直接导入函数。导入语句：`import导入对象`。

自定义函数不会自动检查实参和形参类型是否一致，因此函数定义中最好检查下实参的数据类型是否正确，使用内置函数`isinstance(参数名,(类型1,类型2…))`实现。该函数的返回值：若参数是类型1，2，3…中的某一种，返回true，否则false。

**pass语句：** 什么都不做的空函数函数体为pass，可以用作占位符。~~（如果还没想好这个函数要怎么写的话2333）~~

**全局变量：** 函数体内的变量是局部变量（同c语言），若要使用函数体外定义的变量，需要实现声明该变量是global变量。如global x

**闭包结构：** 可以在函数中定义内部函数，并返回这个函数。内部函数可以引用外部函数的局部变量和参数。这种结构称为**闭包**，即内部函数保存了外部函数的变量和参数。调用外部函数时，内部函数并没有被调用。多次调用内部函数时，内外部函数的变量如果已经在第一次调用内部函数时就被改变过，那么后续调用时使用的都是改变后的值。

### 参数类型：

#### 默认参数：
定义有多个参数的函数时，如果在定义函数`fx(a,b)`时就给参数b进行赋值`fx(a,b=2)`，则这个值会成为参数b的默认值。当调用时可以选择省去参数b，若这样做，则b的值缺省为2.函数定义时，默认参数要放在各项参数的最后。

调用函数时，给默认参数赋值的问题：可以不赋值（缺省），可以按顺序赋值，也可指定默认参数赋值。如`fx(m,b=n)`。
注意：python自定义函数内默认参数修改的可变对象（如list），在函数之外也会改变。可以使用不变对象none和str来避免这一问题。即默认参数必须指向不可变对象。

**好处：** 降低了参数调用的难度。

#### 可变参数：
参数数目可变，本质是接收一个list或tuple。函数定义为：
`fx(*数组名)`。函数调用：`fx(元素1，元素2，元素3…)`

传递的元素自动组装成数组。也可直接传递数组：`fx(*要传递的数组名)`;
也可以将普通参数和可变参数一起传入,
如`def fx(a,b,*c)`，传递参数时`fx(1,2,3,4)`，则`a=1,b=2,c=(3,4)`。

#### 关键字参数：
传入任意个带有名称(key)的参数，传入后参数自动组装成dict。函数定义：`fx(**dict名)`，函数调用：`fx(key1=值1,key2=值2……)`。**注：key名不带引号！** 也可直接传递dict：`fx(**dict名)`。关键字参数是可选的，可以缺省（不传入）。

#### 命名关键字参数：
只接受特定key作为关键字参数，需要在定义时对关键字参数命名：`fx(*,key1,key2……)`，即在分隔符`*,`之后指明只接受那些key名作为关键字参数。在函数调用时，也只能传入（且必须传入，除非缺省时）这些key名对应的dict。传递错误或没有传入则会报错。如果在命名关键字参数前有了可变参数，则无需加上*,：如`Fx(*数组名,key1,key2……)`。
命名关键字参数也可以在定义时赋予默认值（缺省值）。如：
```
def person(name, age, *, city='Beijing', job)
```
里面，city是缺省值。

**命名关键字参数与其他参数混用：**`fx(a,b,*,ket1,key2),fx(a,b,*数组名,key1,key2)`


#### 参数组合调用：
对于任意函数，都可以通过类似`func(*args, **kw)`的形式调用它，无论它的参数是如何定义的。即必选参数也可以通过tuple或list传入。

***

<h2 id="t7">高级操作</h2>

**整体赋值：** 如`a,b,c=1,2,3`，结果为a=1,b=2,c=3。本质是转化为元组整体赋值。

**对数组（list，元组，str）切片（Slice）:** 使用操作符“[:]”，`L[0:3]`表示从第0个元素开始取到第3个元素之前（取到第二个元素）.

*  第一个索引是0时可以省略为`L[:3]`
*  第二个索引代表最后一个元素时也可省略，如`L[1:]`。
*  倒数切片：`L[-2:-1]`，
*  若省略两个索引，则`L[:]`表示L的全部元素。

**遍历数组：** 使用`for x in…`语句。对dict而言，x可以是key（遍历所有的key）

*  默认情况下，dict迭代的是key。
*  如果要迭代value，可以用`for value in d.values()`，
*  如果要同时迭代key和value，可以用for k, v in d.items()。

判断一个对象是否可迭代，使用collections模块中的Iterable类型判断。使用函数`isinstance(对象,Iterable)`来判断。可迭代则返回true，否则false。若想像c语言一样，对list进行下标循环，可以使用函数`enumerate(list)`，可以把该list中的每个元素变成（下标，元素）对。可以在for语句中使用两个索引，分别代替对应的变量，如：
```python
 for i, value in enumerate(['A', 'B', 'C']):
```
**列表生成式：** 用来创建list或从已知list推出新的list的式子。格式为：`[x的表达式 for x in 数组名]`如`[x * x for x in range(1, 11)]`
这样可以生成一组数列；

* 也可以加入条件：`[x * x for x in range(1, 11) if x % 2 == 0]`
* 或者加入嵌套循环：`[m + n for m in 'ABC' for n in 'XYZ']`
也即是[元素 条件]的格式。

**生成器（generator）：** 一种动态的结构。与列表生成式直接生成所有数据不同生成器是记录下列表中元素的规则，动态生成，这样节省了存储空间。定义方法：

*  元素的生成规则比较简单，可以用列表生成式表示的时候，直接将列表生成式最外层的`[]`变为`()`。
* 元素的生成规则比较复杂时（如斐波那契数列），可以使用定义函数形式的生成器：只要在在函数中使用`yield`关键字，`yield`有些类似`print`，假如把`yeild`替换成`print`，那么每次打印出的值就是生成器的各个元素的值。

获取生成器中元素的方法：

*  使用`next(生成器名)`，会从头开始返回生成器中的下一个元素
*  生成器是可迭代对象，可以使用使用`for x in 生成器`。

### 模块

导入：`import 模块名 as 缩写名`，单独导入部分模块：`from 模块名 import 子模块/子类/子函数`

导入自己的模块：

* 在模块中添加`main()`函数，并加入以下语句：
    ```python
    if __name == '__main__':
        main()
    ```
    这表示当该程序直接启动时，执行`main()`，作为模块导入该程序时，不执行`main()`

### 高阶函数
函数本身可以赋值给变量（类似指向函数的指针），函数名也是变量。函数也可以接受另一个函数名作为参数。函数名的数据类型实际上是<font color= 'red'>function类</font>。

python的高级操作：

*  **Map函数：** 可以迭代使用函数。函数原型为：`map(函数名f，可迭代对象a, 可迭代对象b...)`，map的作用是多次调用`f`，`a，b...`是多个可迭代对象，每一组`a[i], b[i]...`构成传给f的参数，如果`a,b...`不等长，会自动截断，`map`会返回由各个返回值构成的可迭代对象`c`。
*  **Reduce函数：** 可以递归使用函数。函数原型为reduce(函数名f，可迭代对象a)，假设a=[x1,x2,x3,x4]，那么reduce的作用相当于:`f(f(f(x1, x2), x3), x4)`
*  **匿名函数：** 格式为`(lambda x: 关于x的表达式)`，例如`(lambda x: x*x)`，一般用于只使用一次的函数，以及担心函数名冲突的时候。可以把匿名函数表达式赋值给变量，然后通过该变量来调用函数。
*  **Filter函数：** 用于过滤序列，函数原型为filter(函数名f,序列a)，filter将传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

#### 闭包

在外函数中定义内函数，内函数调用外函数中的变量，外函数的返回值是内函数的函数名，这样就构成了闭包。闭包的作用是可以保证外函数中临时变量即使在外函数执行完毕后，也不会被释放。例如：
```python
def f(x):
    y = 10
    def g(x):
        print(x+y)
    return g
func = f(5)
# [out] 15
```

* 要在内层函数中修改外部变量时，要求被修改的变量必须是可变类型（如`list`）
* 多次执行闭包时，内层函数的内存空间一直不被释放，因此每一次迭代使用的变量都是同一个（会有累加效应）

闭包的作用：OOP，装饰器

#### 装饰器

一种不需要修改函数的源代码就可以为函数增加功能的高级方法，要使用到闭包。假设要给函数`func`增加功能，装饰器的做法是：写一个闭包`closure`，传入`func`，并把要增加的功能作为内函数，然后在原来`func`的定义前一行加入`@closure`即可：

```python
def closure(func):
    def wrapper(*args, **kargs):    # 参数应该包含func的参数，或者也用*args, **kargs来应对任意形式的参数传递
        [要增加的功能]
        return func(*args, **kargs) # 这里的参数应该与func原来的参数完全相同，或者使用*args, **kargs来应对任意形式的参数传递
    return wrapper、
@closure 
def func():
    [函数定义]
```

***

<h2 id="t8">文件I/O</h2>

Open函数可以打开一个文件（同c语言）。函数原型为`open(‘文件路径’,’打开方式’)`。打开方式(只读，只写)等同c语言）open函数的返回值可以理解为c语言中的文件指针。对p:

*  有`p.write(‘字符串’)`方法，在文件末尾添加文字；
*  `p.close()`方法以关闭文件。
*  `P.read()`可以读取到对应文件的内容，该方法的返回值是包含文件所有内容的字符串。
*  使用`p.readline()`进行逐行读取。第i次使用该函数读取到的内容是文件的第i行。
*  使用`p.readlines()`可以读取所有行。该函数的返回值是一个list，该；list的每个元素也是list，包含每一行的内容。

***

<h2 id="t9">面向对象(OOP)</h2>

定义一个类：
```python
class Class1(object):			#要求首字母大写且要有冒号。
    Name=’.......’
    Value=.......
    ......						#类的属性。
```
其中object表示该类是从哪个类继承下来的。类的定义中可以有def语句定义函数。在创建该类的一个实例时（对象）

<h2 id="t10">多进程&多线程</h2>

### 多线程

需要导入`threading`模块

* `threading.active_count()`可以返回当前的活跃线程数目
* `threading.current_thread()`查看正在运行的线程。

#### 使用多线程

* 添加线程`thread = threading.Thread(target = func, args = (args))`，`func`是该线程要运行的工作。
* 为线程添加功能：定义上面的`func`函数，参数`args`是由要传给`func`的参数组成的可迭代对象。
    * 所以只有一个参数时，为了保证传入可迭代对象，使用`args=(a, )`。
* 如果函数需要返回值，不能直接返回，一般使用队列(`queue`)的方法来保存多线程的返回值。
    * 队列对象使用`queue.Queue`封装
    * 使用`queue.put(x)`来把`x`放入队列
    * 使用`queue.get(x)`来输出队列中的内容
    使用队列的多线程如下：
    
    ```python
    from queue import Queue

    def func(queue):
        [我是代码]
        queue.put(返回值)

    queue = Queue()
    for _ in range(n):
        t = threading.Thread(target=func, args=queue)
        t.start()
    print(queue.get())
    ```

* 运行线程`thread.start()`。

#### 调度

* 正常情况下，各个多线程时同时工作的。
* 使用`thread1.join()`语句，将`thread1`加入主线程，即主线程运行到该语句处，会等待`thread1`完成任务，主线程再运行之后的代码。
* 使用锁控制线程的运行顺序`lock = threading.Lock()`，在线程对应的函数中，使用:
    ```python
    lock = threading.Lock()
    def func():
        global lock
        lock.acquire()
        [我是代码]
        lock.release()
    ```

### 多进程

需要`multiprocessing`模块，`import multiprocessing as mp`

* 创建进程`process = mp.Process(target=func, args=args)`，参数含义和多线程相同。
    * `func`的返回值也需要队列来完成。这里使用的队列直接使用`multiprocessing`中的队列对象，即`queue = mp.Queue()`，其他操作与多线程相同。
    * 这里的参数
* 开始进程`process.start()`
* 加入主进程`process.join()`
* **注意：**多进程必须在`if __name__ == '__main__'`下运行。

#### 全局锁

* 多进程执行中，如果有需要多个之间共享的变量，需要使用`mp.Value()`封装。具体细节见文档。
* 如果不加锁，各个进程之间使用共享内存会起冲突。建立一个全局锁：`l = mp.Lock()`。使用全局锁就是在某个进程对应的`func`中按如下所示：
    ```python
    l = threading.Lock()
    def func():
        global l
        l.acquire()
        [我是代码]
        l.release()
    ```


#### 进程池`Pool`

* 普通的多进程操作：创建进程->运行进程->加入主进程->使用队列得到返回值
* 使用进程池，把要运行的任务放入池中，可以自动实现多进程计算.
    * 创建进程池：`pool = mp.Pool(processes=n)`，`processes`表示进程数，默认和`cpu`核心数相等
    * 把函数放入池：
        * 如果需要重复执行某个函数，并且该函数只有一个参数，可以使用`return_value = pool.map(func, 可迭代对象)`。这里的可迭代对象是由函数参数构成的（与`python`中的`map`函数类似）
        * 如果只执行一次函数，但函数有多个参数，也可以使用异步非阻塞运行：`res = pool.apply(func, args=(args1, args2...))`，`args`是由各个参数组成的 可迭代对象。
        * 一般使用效率更高的`map`和`apply`异步方法`res = pool.map_async()`和`res = pool.apply_async()`。除了名字不同以外，参数传递完全相同。异步方法不能直接获取返回值，需要用`res.get()` 来获取。

***

未完待续....以后慢慢填坑叭 0v0

其实学到对象之后就进度起飞不怎么做笔记了XD（趴

by WHY,2018.4.10
