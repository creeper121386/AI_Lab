---
title: whyのUnixShell学习记录！
date: 2018-07-21 11:56:58
tags:
- Linux
- 编程
categories: Linux
---

## shell脚本

### 需要注意的事情

* 脚本必须以`#!/bin/bash`开头，表示指定运行脚本的解释器。
* 如果脚本不能运行，记得赋予运行权限`chmod +x xxx.sh`
* 也将脚本所在文件加入环境变量，以便在各处运行。

<!--more-->  

### 基本函数&控制语句

* 可以直接写命令作为一条语句。
* `echo "str1" "str2"...`：打印些东西
* **io重定向**：
    * `command > file`把输出重定向到文件，覆盖写文件。
    * `command >> file`输出重定向到文件，追加写文件。
    * `command > file`从文件获取输入。
* **变量**：声明：`a=1`，表达式内部 **不能有空格**。强迫症表示不开心（哼
    * 使用`readonly a=1`来声明一个只读变量。
    * 使用`unset a`来删除一个变量
    * 用`${}`引用变量：`"I am ${a}"`，花括号可省略。
    * 变量声明之后，所有要使用变量的地方都必须用`${}`的形式。
    * 把命令赋值给变量时，使用反引号：``a=`sudo -s` ``。在命令中
* **数组**：`array=(1 2 3 4)`，用空格分隔，用`array[0]`索引。
    * 引用数组的所有元素：$${array[@]}$
    * 引用数组长度：$${\#array[@]}$
    （这里直接写代码的话博客会报错...我也不造为啥只好用$LaTeX$写了
* **命令行参数**：使用`$0, $1, $2 ...`表示对应的参数。
* **特殊的内置变量**:
    * `$#`:	传递到脚本的参数个数
    * `$*`:	以一个单字符串显示所有向脚本传递的参数。如`"$*"`用`"`括起来的情况、以`"$1 $2 ...$n"`的形式输出所有参数。
    * `$$`:	脚本运行的当前进程ID号
    * `$!`:	后台运行的最后一个进程的ID号
    * `$@`:	与`$*`相同，但是使用时加引号，并在引号中返回每个参数。如`"$@"`用`"`括起来的情况、以`"$1" "$2" … "$n"` 的形式输出所有参数。
    * `$-`:	显示Shell使用的当前选项，与set命令功能相同。
    * `$?`:	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
* **运算符**：不知直接做运算，必须以命令的形式返回运算式的值。如`c=a+b`应写成`` c=`expr a + b` ``
* **关系运算符**：没有`>,<`之类的符号，只有类似命令的表示：
    * `[ $a -eq $b ]`：`a==b`
    * `[ $a -ne $b ]`：`a!=b`
    * `[ $a -gt $b ]`：`a>b`
    * `[ $a -lt $b ]`：`a<b`
    * `[ $a -ge $b ]`：`a>=b`
    * `[ $a -le $b ]`：`a<=b`
    * 方括号里边的空格不能省略！py选手表示不开心（哼
* **布尔&逻辑运算符**：格式和关系运算一样。
    * 布尔运算：`!`非，`-o`或，`-a`与
    * 逻辑运算：`&&`与逻辑，`||`或逻辑
* **文件判断、字符串运算符**：啊啊啊好多啊直接贴![链接](http://www.runoob.com/linux/linux-shell-basic-operators.html)
* **条件语句**：
    ```shell
    if [ $a == $b ]
    then 
        我是代码
    elif 
    then
        我是代码
    else 
        我是代码
    fi    
    ```
* **for循环：**
    ```shell
    for x in list:
    do
        我是代码
    done
    ```
* **while循环：**
    ```shell
    while condition:
    do 
        我是代码
    done
    ```
* **until循环**：执行代码直到条件为真时停止：
    ```shell
    until condition
    do
        我是代码
    done
    ```
* `break`和`continue`用法与其他语言一致。

### 自定义函数

* 定义一个名为`fx`的函数：
    ```shell
    function fc () {
        我是代码
        [return value]
    }
    ```
* 定义开头的`function`可省略。
* 传参给函数时，函数内部使用`$1, $2 ...`来表示参数。
* 删除函数：`unset.f fx`

### 导入外部文件

`source filename`或者`. filename`

## expect命令

### API

一种可以完成交互操作的`shell`，使用`tcl`语法。脚本需要在开头注明`#!/bin/expect`。基本命令有：

* `set timeout x`：设定执行命令若`x`秒没有回应，就跳过执行下一条。
* `spawn 命令`：启动一个新的进程来执行`spawn`后的命令。
* `expect "Regex"`：表示终端接收到符合匹配的输出时，执行`expect`之后的命令。
* `send "str"`：以交互的形式向终端发送字符串。如果要模拟用户输入，要在最后加入换行符`\r`。
* `expect "Regex" {send "str"}`：只有正则匹配成功时才执行`send`。
* 那个表达式匹配成功，就执行相应的`send`。可以所有的`send`都执行。

```shell
expect{
    "Regex1" {send "str1"}
    "Regex2" {send "str2"}
    "Regex3" {send "str3"}
}
```

### 控制语句

* **函数**，其中`a,b,c`是参数：
    ```shell
    #定义：
    proc fx {a b c} {
        我是代码
    }
    #调用:
    fx a b c
    ```
    要注意大括号两边必须有空格。
