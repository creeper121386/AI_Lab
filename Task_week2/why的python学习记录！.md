---
title: # 文章标题  
date: 2017/3/27 13:48:25  # 文章发表时间
tags:
- python
- code
categories: python
thumbnail: "python.jpg"
---
# **why的Python学习记录!**
#### 大家一起愉快地写代码叭!

***
## **目录**
* [linux下的Python配置](#t2)
* [python运算符](#t3)
* [控制流与API](#t4)
* [数据类型](#t5)
* [自定义函数](#t6)
* [高级操作](#t7)
* [文件I/O](#t8)
* [面向对象(OOP)](#t9)
***
## <h2 id="t2">Linux下的Python配置</h2>
atom安装Python插件，或者使用IDE (spyder,pycharm)。程序运行的两种模式：命令行模式（直接运行）与Python交互模式（逐句执行）。
***
## <h2 id="t3">Python运算符</h2>
>+,-,* ,/,//（取商的整数部分）,** （x**,x的y次幂）,>>,<<,&,|,^,~,>,<,>=,<=,==,!=,not,and,or

## <h2 id="t4">控制流与API</h2>
### 需要注意的事情：
句末不加分号（当然如果你想加的话也可以23333），函数块用缩进表示，字符串可以用单引号引用。

**标准输入输出函数：** print(),input()。Print末尾自动换行，可以通过在末尾添加逗号来取消末尾的换行符。print语句可以像c语言一样使用转换说明来打印变量。如
```python
print(“hello %s”%(“world!”))。
```
特别地，%s除了表示字符串以外，也可以表示list。a=input(“xxxxxxx”)表示把输入的数据赋值给a，并在输入前显示一行提示语句。在python3中input函数默认将键盘输入作为str看待，若想接受int类型，应当使用```int(input())```.
返回字符串长度/列表元素个数：```len()```

**条件函数if：**
```python
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
<执行4>
```
**循环语句：** ```for x in…```循环：把…(一个数组)的每一个元素赋值给x（即x的值在循环体中表示的是数组的相应元素）执行循环体。

**range(101)：** 生成一个元素为整数0-100的序列（数组）。Range(m,n)生成从m到n前一个数字的数组。```Range(1,5,2)```中2表示步长（缺省为1）生成list[1,3]

**while循环：** ```while x```，同c语言。可使用break退出循环，或用continue结束本轮，执行下次循环。
注：在while或for语句块后可以跟随else。若在循环体中使用break语句，else部分也会被跳过。

**尾递归：** 函数的最后一步只调用函数本身，且返回语句不含表达式的递归。如：
```python
def tailrecsum(x, running_total=0):
if x == 0:
return running_total
else:
return tailrecsum(x - 1, running_total + x)
```
是尾递归，而：
```python
def recsum(x):
  if x == 1:
    return x
  else:
return x + recsum(x - 1)
```
不是尾递归。因为函数的最后一步return语句中有表达式。使用尾递归，使得循环时内层函数不必使用外层函数中的值，无需储存上一层函数中的数据，只占用一个栈帧，可以避免栈溢出风险。

**暂停1s输出：** time.sleep(1)
***
## <h2 id="t5">数据类型</h2>
**整形数据（int），浮点（float），字符串（str），布尔值（bool），none：** 同c语言

**复数（complex）：** a+bi表示为``complex(a,b)``或`a+bj`，其中a和b是浮点型。

#### **列表（list）：**
是可变的数据类型。定义：```A=[a,b,c]```，列表的内容可以是不同的类，甚至可以是list，若这么做，相当于二维数组。
列表通过下标访问。``A[-n]``表示倒数第n个元素。

* ``A.append(‘xxxxx’)``表示向列表末尾加入元素
* ``A.insert(n,’xxxxx’)``表示向A[n]处插入新元素。
* 删除list的元素:使用`A.pop()`删除末尾元素，`A.pop(i)`删除指定位置的元素（也可使用`del(A[i])`来删除指定位置的元素）。
* 对list的元素进行排序：使用`A.sort()`语句。使用该语句后，List本身的内容会被改变。

#### **元组（tuple,const）：**
是不可变的数据类型。一旦初始化就不能修改。其内容也可以是不同的类，包括list。成员中有list时，**list中的元素可变**，但不能对list整体修改。元组中的元素通过下标访问。定义：`A=(a,b,c)`。元素只有一个时，应定义为`A=(a,)`来消歧义。

#### **字典（dict）：**
是可变的数据类型。查找速度快，但内存浪费多（空间换取时间）。声明语句如
```python
d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
```
每个元素的名称（**key**）和值一一对应，key不能重复，且必须为不可变对象。字典中的某个key代表的元素表示为：``d['Jack']``，对应值为88。
* 通过`’x’ in d`语句判断该元素是否存在（是否被定义）。存在则该语句的值为真，反之为假。
* 也可以使用`d.get(‘Michael’)`表达式判断，若该键没有对应的值则返回none。该表达式可指定不存在时的返回值：`d.get(‘Michael’，-1)`
* 使用`d.keys()`单独提取dict中的key为一个数组；
* 使用`d.values()`单独提取值为一个数组；
* 使用`d.items()`将key和对应的值同时提取为数组，数组的每个元素是一个tuple。

**注意：** 此处的“数组”是不严谨说法，其实他们的数据类型既不是list也不是tuple。

#### **Set：**
一组key的集合，但不存储值。声明：`s = set([1, 2, 3])`。
Key不可变，且不能重复，因此set的元素都是不可变对象，并且没有相同元素。Add(key)可以加入新元素，
* `remove(key)`可以删除元素。
* 两个set可以进行数学上集合的交并操作，使用`&`和`|`。

#### **字符串(str,const)：**
大致同c，不可变的类型。若`a=’abc’`
* 想要改变a的值，可以使用`a=a.replace(‘a’,’A’)`。也只有字符串类型可以使用replace函数。Replace函数的返回值是改变后的串内容，但a本身并没有改变。要想改变，需要进行赋值操作，即`a=a.replace(‘a’,’A’)`。
* 将字符串内容两边加上空格：`s.center()`。
* 将字符串s中的所有大写字母变成小写，使用`s.lower()`方法。
* 变成大写：`s.upper()`。

字符串中可以用转义字符`\’`表示单引号，`\\`表示反斜线，在行末使用`\`可以在下一行续写字符串。

**可迭代对象：** 包括集合数据类型，如list、tuple、dict、set、str等；
以及generator，包括生成器和带yield的generator function。可以使用函数`isinstance()`来判断一个对象是否是可迭代对象。可以被`next()`函数不断返回下一个值的对象称为迭代器（iterator）。For循环本质就是不断调用next函数来实现的。
***
## <h2 id="t6">自定义函数</h2>
函数定义语句：
```python
def 函数名(参数):
	函数体
```
Python中的自定义函数使用```return```语句返回值。可以返回多个值，如``return 0,1``。返回多个值的本质是返回了一个tuple。若不写返回语句，则返回值为none。
与含有函数定义的py文件的同级目录下的文件可以直接导入函数。导入语句：```import导入对象```。

自定义函数不会自动检查实参和形参类型是否一致，因此函数定义中最好检查下实参的数据类型是否正确，使用内置函数```isinstance(参数名,(类型1,类型2…))```实现。该函数的返回值：若参数是类型1，2，3…中的某一种，返回true，否则false。

**pass语句：** 什么都不做的空函数函数体为pass，可以用作占位符。~~（如果还没想好这个函数要怎么写的话2333）~~

**全局变量：** 函数体内的变量是局部变量（同c语言），若要使用函数体外定义的变量，需要实现声明该变量是global变量。如global x

**闭包结构：** 可以在函数中定义内部函数，并返回这个函数。内部函数可以引用外部函数的局部变量和参数。这种结构称为**闭包**，即内部函数保存了外部函数的变量和参数。调用外部函数时，内部函数并没有被调用。多次调用内部函数时，内外部函数的变量如果已经在第一次调用内部函数时就被改变过，那么后续调用时使用的都是改变后的值。

### 参数类型：
#### 默认参数：
定义有多个参数的函数时，如果在定义函数``fx(a,b)``时就给参数b进行赋值``fx(a,b=2)``，则这个值会成为参数b的默认值。当调用时可以选择省去参数b，若这样做，则b的值缺省为2.函数定义时，默认参数要放在各项参数的最后。

调用函数时，给默认参数赋值的问题：可以不赋值（缺省），可以按顺序赋值，也可指定默认参数赋值。如``fx(m,b=n)``。
注意：python自定义函数内默认参数修改的可变对象（如list），在函数之外也会改变。可以使用不变对象none和str来避免这一问题。即默认参数必须指向不可变对象。
**好处：** 降低了参数调用的难度。

#### 可变参数：
参数数目可变，本质是接收一个list或tuple。函数定义为：
``fx(*数组名)``。函数调用：``fx(元素1，元素2，元素3…)``

传递的元素自动组装成数组。也可直接传递数组：``fx(*要传递的数组名)``;
也可以将普通参数和可变参数一起传入,
如``def fx(a,b,*c)``，传递参数时``fx(1,2,3,4)``，则``a=1,b=2,c=(3,4)``。
#### 关键字参数：
传入任意个带有名称(key)的参数，传入后参数自动组装成dict。函数定义：``fx(**dict名)``，函数调用：``fx(key1=值1,key2=值2……)``。**注：key名不带引号！** 也可直接传递dict：``fx(**dict名)``。关键字参数是可选的，可以缺省（不传入）。
#### 命名关键字参数：
只接受特定key作为关键字参数，需要在定义时对关键字参数命名：``fx(*,key1,key2……)``，即在分隔符``*,``之后指明只接受那些key名作为关键字参数。在函数调用时，也只能传入（且必须传入，除非缺省时）这些key名对应的dict。传递错误或没有传入则会报错。如果在命名关键字参数前有了可变参数，则无需加上*,：如``Fx(*数组名,key1,key2……)``。
命名关键字参数也可以在定义时赋予默认值（缺省值）。如：
```python
def person(name, age, *, city='Beijing', job)
```
里面，city是缺省值。

**命名关键字参数与其他参数混用：**``fx(a,b,*,ket1,key2),fx(a,b,*数组名,key1,key2)``


#### 参数组合调用：
对于任意函数，都可以通过类似``func(*args, **kw)``的形式调用它，无论它的参数是如何定义的。即必选参数也可以通过tuple或list传入。
***
## <h2 id="t7">高级操作</h2>
**整体赋值：** 如`a,b,c=1,2,3`，结果为a=1,b=2,c=3。本质是转化为元组整体赋值。

**对数组（list，元组，str）切片（Slice）:** 使用操作符“[:]”，`L[0:3]`表示从第0个元素开始取到第3个元素之前（取到第二个元素）.
* 第一个索引是0时可以省略为`L[:3]`
* 第二个索引代表最后一个元素时也可省略，如`L[1:]`。
* 倒数切片：`L[-2:-1]`，
* 若省略两个索引，则`L[:]`表示L的全部元素。

**遍历数组：** 使用`for x in…`语句。对dict而言，x可以是key（遍历所有的key）
* 默认情况下，dict迭代的是key。
* 如果要迭代value，可以用`for value in d.values()`，
* 如果要同时迭代key和value，可以用for k, v in d.items()。

判断一个对象是否可迭代，使用collections模块中的Iterable类型判断。使用函数`isinstance(对象,Iterable)`来判断。可迭代则返回true，否则false。若想像c语言一样，对list进行下标循环，可以使用函数`enumerate(list)`，可以把该list中的每个元素变成（下标，元素）对。可以在for语句中使用两个索引，分别代替对应的变量，如：
```python
 for i, value in enumerate(['A', 'B', 'C']):
```
**列表生成式：** 用来创建list或从已知list推出新的list的式子。格式为：
```python
[x的表达式 for x in 数组名]如[x * x for x in range(1, 11)]
```
这样可以生成一组数列；
* 也可以加入条件：`[x * x for x in range(1, 11) if x % 2 == 0]`
* 或者加入嵌套循环：`[m + n for m in 'ABC' for n in 'XYZ']`
也即是[元素 条件]的格式。

**生成器（generator）：** 产生列表生成式的机制（算法）。定义方法：
* 将列表生成式最外层的[]变为()即可。
* 在函数中包含yield关键字。这样定义的生成器在执行时不会做函数调用，遇到yield语句时中断并返回值，下次执行时从yield语句继续迭代。

调用生成器的方法：
* 使用next(生成器名)函数。
* 使用for x in 生成器名循环语句（生成器是可迭代对象）。
###模块
导入：`import 模块名`，单独导入部分模块：`from 模块名 import 名称`
###高阶函数
函数本身可以赋值给变量（类似指向函数的指针），函数名也是变量。函数也可以接受另一个函数名作为参数。函数名的数据类型实际上是<font color= 'red'>function类</font>。

python的骚操作：
* **Map函数：** 可以迭代使用函数。函数原型为：`map(函数名f，可迭代对象a)`，map将会把函数f依次作用在a的每一个元素上，然后返回新的可迭代对象b。
* **Reduce函数：** 可以递归使用函数。函数原型为reduce(函数名f，可迭代对象a)，假设a=[x1,x2,x3,x4]，那么reduce的作用相当于:
`f(f(f(x1, x2), x3), x4)`
* **匿名函数：** 格式为`(lambda x: 关于x的表达式)`，例如`(lambda x: x*x)`，一般用于只使用一次的函数，以及担心函数名冲突的时候。可以把匿名函数表达式赋值给变量，然后通过该变量来调用函数。
* **Filter函数：** 用于过滤序列，函数原型为filter(函数名f,序列a)，filter将传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

***
## <h2 id="t8">文件I/O</h2>
Open函数可以打开一个文件（同c语言）。函数原型为`open(‘文件路径’,’打开方式’)`。打开方式(只读，只写)等同c语言）open函数的返回值可以理解为c语言中的文件指针。对文件指针p:
* 有`p.write(‘字符串’)`方法，在文件末尾添加文字；
* `p.close()`方法以关闭文件。
* `P.read()`可以读取到对应文件的内容，该方法的返回值是包含文件所有内容的字符串。
* 使用`p.readline()`进行逐行读取。第i次使用该函数读取到的内容是文件的第i行。
* 使用`p.readlines()`可以读取所有行。该函数的返回值是一个list，该；list的每个元素也是list，包含每一行的内容。
***
## <h2 id="t9">面向对象(OOP)</h2>定义一个类：
```python
class Class1(object):			#要求首字母大写且要有冒号。
Name=’.......’
Value=.......
......						#类的属性。
```
其中object表示该类是从哪个类继承下来的。类的定义中可以有def语句定义函数。在创建该类的一个实例时（对象）
***
未完待续....以后慢慢填坑叭 0v0

其实学到对象之后就进度起飞不怎么做笔记了XD（趴

by WHY,2018.4.10
